## Android基础

* Android序列化的三种方式（其实实际上是两种）：

  **Serializable接口**(Java自带）：此方法由于基于java反射导致会有很多临时变量，会导致频繁GC，速度比用parcelable接口慢一些。但是写起来十分方便，只需要对应的类去实现此接口即可。可用于网络传输和持久化到本地。

  ```java
  public class A implements Serializble {
      public static final long serialVersionUID = 1L;//一定程度上保证反序列化成功，除非类发生毁灭性重构，如换了类名。
      private String username;
      private transient String password;
      
      public static void main(String[] args) {
          
      }
  }
  ```

  **Externalizble接口**（Java自带）：继承了Serializble接口，可以自己用writeExternal与readExternal方法指定序列化的对象，在此时若被指定对象被transient修饰依然会被序列化。

  **Parcelable接口**（Android专用）：不同于将对象序列化，此接口是将一个完整的对象进行分解，分解后的每一个部分都是Intent所支持的类型，实现了传递对象的功能。但是此接口不推荐用于持久化数据，因为考虑到升级的时候类的结构可能会有一些变动如加个字段，这个时候以二进制的格式反序列化的时候会crash掉（parcelable严重依赖于写入顺序），可以考虑用json的格式持久化，若是处于性能考虑用此接口持久化数据则需要确保类的结构不会发生变化。此接口更多用于进程间通信。

  使用此接口需要有一个实现了Parcelable.Creator接口的静态非空变量CREATOR。

* transient的作用：在序列化类的时候将不需要序列化的信息用此关键词修饰即可，一般用于不希望持久化或者在网络上传输的信息（比如密码）。敏感信息仅存在于程序内存中。另外静态变量不会被序列化。

* 序列化的作用：序列化表示将一个对象转换成可存储和可传输的状态，可以在网络上传输也可以存储到本地。在Android开发中无法将对象的引用传给Activities或Fragments，我们需要将这些对象放到Intent或Bundle中，然后再传递。

* volatile：禁止jvm指令重排列

* 自定义view：

* Handler：

* Binder：

* Activity：

* Fragment：

* BroadcastReceiver：

* ContentProvider：

* Intent：

* Service：

* 卡顿：

* String：String是引用类型，底层由char数组实现，String是final类故而不可继承。涉及到大量字符串的合并考虑使用StringBuilder或StringBuffer，后者线程安全，前者线程不安全。

* 线程池：当有大量简单任务需要用多个线程来完成的时候，不断地创建销毁线程十分消耗资源，甚至有可能在创建新线程和销毁线程上用的时间比处理任务用的时间还多。线程池就是为此提出的。

  使用线程池可以提高响应速度，降低资源消耗，提高线程的可管理性。对于最后一点的解释为：线程是一种稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

* 抽象类和接口：抽象类可以有方法实现细节，接口只能存在抽象方法。抽象类可以有静态代码块和静态方法而接口不行。只能继承一个抽象类，可以实现多个接口（多重继承效果还可考虑内部类）。接口对行为抽象，抽象类对整体抽象。继承可以理解为“是不是”的关系，接口可以理解为“能不能”的关系。接口中的成员变量要声明为public static final，不加编译器不会报错，但是这就使得接口变得毫无意义。之所以要加static是因为接口是可以多继承的，而如果有两个接口里面都有同一个变量名，那么怎么知道这个变量名是谁的，所以要有static，而final则是因为如果谁都可以来更改接口中的变量，那么接口的至高抽象地位就丧失了（个人理解，不一定对）。当然一般接口中有成员变量的情况不是太常见。

* 强软弱虚四种引用：强引用是一般情况下的对象引用，除非置为null，不然宁可OutOfMemoryError也不会GC掉强引用。软引用是当内存不足的时候会被回收掉，因此可以用来实现内存敏感的高速缓存，可以与一个引用队列一起使用。弱引用则是每当GC的时候无论是否内存不足，都会被回收掉，可以与一个引用队列一起使用。虚引用则更像是一个空引用，仅仅给它贴了一个标签，但是什么作用都没有，必须要与一个引用队列一起使用。

* Map：

* 启动线程的方式：

* 实现线程：

* sync与Lock区别：

  | 类别     | synchronized                                                 | Lock                              |
  | -------- | ------------------------------------------------------------ | --------------------------------- |
  | 存在层次 | Java关键字，JVM层                                            | 是一个类                          |
  | 锁的释放 | 已获取锁的线程执行完同步代码，释放锁<br />线程执行发生异常，JVM会让线程释放锁 | 在finally中必须释放，不然容易死锁 |
  | 锁的获取 | 假设A线程获得锁，B线程等待，此时A阻塞，B会一直等待           | 可以尝试获得锁，线程不用一直等待  |
  | 锁状态   | 无法判断                                                     | 可以判断                          |
  | 锁类型   | 可重入 不可中断 非公平                                       | 可重入 可中断 公平/非公平皆可     |
  | 性能     | 少量同步，性能稍高                                           | 大量同步，性能稍低                |

  

* wait(),sleep(),notify()：

* Java锁：公平锁--按照等待时间的长短，等的时间越长，越是优先获得锁。非公平锁--不按照等待时间来算优先级，谁都可能先获得锁。

## Android框架

* OKhttp：

* Retrofit：
* Glide：

## 网络基础

* TCP：

* UDP：

* HTTPS：

* HTTP：

* 负载均衡：使用这种技术的原因是如果只有一个服务器则web请求是这样的：User=>Internet=>Web Server=>Database Server，把鸡蛋放在一个篮子里是非常危险的，如果这个服务器发生了意外宕机则此网络资源无法访问。另外如果这个网站很受欢迎，有很多用户发起请求，在这种情况下单个服务器即使配置很高也很难处理如此多的请求，而且从经济的角度考虑，追求数量比追求配置更划算，又可以提高性能与可用性，实在没有理由不用。当然负载均衡需要额外的机器来实现，将其称为负载均衡器，一般会有几台负载均衡器来做转发，来保证不会出现因为负载均衡器挂掉使应用无法响应的情况。将请求转到另外一个负载均衡器可以使用浮动IP。

  负载均衡器主要可以为四种类型的请求设置转发规则：TCP,UDP,HTTP,HTTPS。负载均衡器会选择能对请求做出正常应答的服务器进行转发，为了监视后台服务器的状态，检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器，如果后端服务器无法通过检查则会被从healthy pool中移除，直到它通过检查为止。

  负载均衡有几个常用算法：轮询--第一个请求发到列表中的第一个服务器，第二个请求发到第二个服务器，以此类推，然后循环。最小连接--优先选择连接数最小的服务器，在普通会话较长的情况下推荐使用。Source--根据请求IP的hash值来选择要转发的服务器，可以一定程度上保证特定用户能连接到相同的服务器。

## JVM

* 新生代、老生代：（本条目下的内存特指Java堆与方法区）在多次GC之后仍然存在于内存中的对象会被移入老生代，新生代与老生代的回收算法大致如下：

  标记-清除：在堆中有效内存将要耗尽时，停下整个程序（stop-the-world），然后进行标记和清除工作，遍历所有GC Roots，然后根据根搜索算法的结果将所有可达对象标记为存活对象（标记位置为1），然后再遍历一遍堆中所有对象，将没有标记的对象（标记位为0）全部清除掉。之后将存活的对象标记位重新置为0。此种方法的缺点是多次遍历堆中对象以及要维护一个空闲列表导致的效率低下以及清理出的内存空间不连续。

  复制-清除：将原有内存空间分为两块，每次只使用其中一块，在GC的时候将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中所有的对象，将两个内存块的角色互换。因为效率比较高但是不适合有大量对象存活的情况，所以用在新生代比较合适。此方法牺牲空间换时间，实际使用的时候会将新生代内存分为一块比较大的Eden空间和两块比较小的survivor空间（Eden：survivor = 8：1），每次使用一块survivor空间和Eden空间，GC时将两块空间内存活的对象复制进入另外一块survivor空间内，然后将两块survivor空间互换角色，这样就可以很大程度上的避免了空间的浪费，仅浪费了10%却又保证了算法的效果。当有些对象比较大不能放进survivor空间的时候则会将**大对象直接放进老生代**，判断大对象的阙值可以自己指定也可使用默认值。

  标记-整理：在标记清除的基础上做了一些改动，将存活的对象堆到内存的一侧，而将另一侧全部清除掉，如此不必维护一个空闲列表只需要知道可用内存的起始地址即可。可用于老生代GC。

  ps：**stop-the-world**是java中一种全局暂停现象，native代码可以运行但是不能与JVM交互，通常由GC引起，少数情况下可能由死锁检查、dump线程、堆dump导致。至于为什么要全局暂停可以形象的理解为我们在一边嗑瓜子一边吐瓜子皮，保洁阿姨进来打扫卫生，而我们这个时候不是让到一边让保洁阿姨打扫干净，而是继续往地上吐瓜子皮...频繁GC的危害就显而易见了，轻则卡顿，重则无响应，一些高可用性集群（HA）长时间无响应引起主备机切换可能会导致灾难性后果。

## 计算机基础概念

* 动态链接与静态链接与PIC：静态链接会将目标程序（也就是你正在写的程序）所需要的库都复制一个副本一起编译，由于每个可执行文件都保留一个副本从而导致了空间的浪费以及单个文件过大，不同的程序有很多公用的代码造成冗余。且由于静态链接所有文件都必须共同链接以确定某个符号或者是代码的位置，导致了单个文件有一点点改动则需要重新编译整个程序。静态编译的好处就是程序执行速度快且可以自己在程序内修改副本而不用担心对其他程序产生影响。

  动态链接则可以在编译时用到哪个再去加载某个库而不用将需要的库都复制进程序里面（不同进程间共享内存通过地址映射解决），这就要求每个程序对动态链接库的同一个符号的引用是不同的。在**Linux进程的五个段中**（bbs段：存放未初始化的全局变量，数据段：存放初始化全局变量，代码段：存放程序执行代码，堆：执行时动态分配，栈：存放局部变量以及函数的参数）代码段由于是共享所以是相同的，从动态链接功能上可以看出应该放在全局变量对应的段，所以我们只能在数据段做文章。每个应用程序的数据段开头位每一个全局符号保留了一个GOT（global offset table），其中每个条目都保存了全局符号的绝对位置（在动态链接库装载的时候被填写）。使用全局符号时去GOF中遍历即可。

* 进程与线程：一个程序至少有一个进程，一个进程至少有一个线程，进程使得操作系统并发成为可能，线程使得进程内部并发成为可能，进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位，进程切换上下文耗时长，线程切换上下文耗时短。从CPU的角度来看，线程与进程其实可以理解为CPU工作时间段的描述。CPU是很快的，在CPU的角度上所有的任务都是轮流进行的：先加载程序A的上下文，然后执行A，然后保存A的上下文，然后加载B程序的上下文，然后执行B，然后保存B的上下文...

  进程就是包含上下文切换的程序执行时间总和，而线程是在这其中运行的更细小的时间段，因为不需要去保存整个程序的上下文，所以切换的时候保存的上下文信息比较少，切换速度快。

* 死锁：死锁发生的情况就是A进程占用着a资源，B进程占用着b资源，但是A和B都需要对方所占用的资源才继续运行下去，于是发生死锁。拆分总结一下死锁的四个条件是：禁止抢占--系统资源不能被强制从一个进程退出；持有和等待--一个进程可以在等待时持有系统资源；互斥--一个资源只能被一个进程持有；循环等待--一系列进程互相持有其他进程所需要的资源。只有当以上四个条件同时满足的时候死锁才会发生，预防死锁就是至少破坏其中一项。如果已经发生死锁，则终止一个进程的运行即可，或是回滚...当然也可以关机重启（0__0）