## Android基础

* Android序列化的三种方式（其实实际上是两种）：

  **Serializable接口**(Java自带）：此方法由于基于java反射导致会有很多临时变量，会导致频繁GC，速度比用parcelable接口慢一些。但是写起来十分方便，只需要对应的类去实现此接口即可。可用于网络传输和持久化到本地。

  ```java
  public class A implements Serializble {
      public static final long serialVersionUID = 1L;//一定程度上保证反序列化成功，除非类发生毁灭性重构，如换了类名。
      private String username;
      private transient String password;
      
      public static void main(String[] args) {
          
      }
  }
  ```

  **Externalizble接口**（Java自带）：继承了Serializble接口，可以自己用writeExternal与readExternal方法指定序列化的对象，在此时若被指定对象被transient修饰依然会被序列化。

  **Parcelable接口**（Android专用）：不同于将对象序列化，此接口是将一个完整的对象进行分解，分解后的每一个部分都是Intent所支持的类型，实现了传递对象的功能。但是此接口不推荐用于持久化数据，因为考虑到升级的时候类的结构可能会有一些变动如加个字段，这个时候以二进制的格式反序列化的时候会crash掉（parcelable严重依赖于写入顺序），可以考虑用json的格式持久化，若是处于性能考虑用此接口持久化数据则需要确保类的结构不会发生变化。此接口更多用于进程间通信。

  使用此接口需要有一个实现了Parcelable.Creator接口的静态非空变量CREATOR。

* transient的作用：在序列化类的时候将不需要序列化的信息用此关键词修饰即可，一般用于不希望持久化或者在网络上传输的信息（比如密码）。敏感信息仅存在于程序内存中。另外静态变量不会被序列化。

* 序列化的作用：序列化表示将一个对象转换成可存储和可传输的状态，可以在网络上传输也可以存储到本地。在Android开发中无法将对象的引用传给Activities或Fragments，我们需要将这些对象放到Intent或Bundle中，然后再传递。

* volatile：禁止jvm指令重排列，保持变量对各线程的可见性。

* Android任务栈：activity一共有四种启动类型，分别是standard标准模式，SingleTask，SingleTop，SingleInstance。其中standard会直接重新新建一个activity的对象，singletop则会看栈顶是否有同类型的activity，如果有就复用栈顶元素，如果栈顶没有此类型activity，则不管栈内其他地方是否有此类型activity，都会将新建一个activity。singletask则在singletop之上更进一步，如果栈内有此类型activity则复用已存在的activity并且将其置于栈顶，置于栈顶的逻辑是若此activity不是栈顶元素则将其上所有activity全部出栈并回调onNewIntent方法，若本身即为栈顶则与singletop一致。而singleInstance则是整个系统内只有唯一的一个此类型的activity，并且独享一个任务栈。

* scheme跳转协议：一种页面内跳转协议，很方便的实现在H5页面跳转到某个指定activity、在app内部跳转到各个页面。在应用内向H5页面注册url scheme，然后由scheme协议从浏览器启动activity。

* 自定义view：

* Handler：

* Binder：

* Activity：

* Fragment：Fragment最开始是为了大屏应用而开发出来的，在一个页面内填充多个碎片来达到想要的效果，后来由于fragment占用内存少，可以动态加载到activity等特点，和viewpager一起被用于页面滑动。可以在xml界面直接添加静态的fragment，也可以动态用FragmentManager和FragmentTransaction加载到activity。

  FragmentPagerAdapter适用于页面较少的情形（detach不回收内存）、FragmentStatePagerAdapter适用于页面较多的情形（remove回收内存）。

* BroadcastReceiver：

* ContentProvider：

* Intent：

* Service：

* Android启动过程：

* 卡顿：

* String：String是引用类型，底层由char数组实现，String是final类故而不可继承。涉及到大量字符串的合并考虑使用StringBuilder或StringBuffer，后者线程安全，前者线程不安全。

* 线程池：当有大量简单任务需要用多个线程来完成的时候，不断地创建销毁线程十分消耗资源，甚至有可能在创建新线程和销毁线程上用的时间比处理任务用的时间还多。线程池就是为此提出的。

  使用线程池可以提高响应速度，降低资源消耗，提高线程的可管理性。对于最后一点的解释为：线程是一种稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

* 抽象类和接口：抽象类可以有方法实现细节，接口只能存在抽象方法。抽象类可以有静态代码块和静态方法而接口不行。只能继承一个抽象类，可以实现多个接口（多重继承效果还可考虑内部类）。接口对行为抽象，抽象类对整体抽象。继承可以理解为“是不是”的关系，接口可以理解为“能不能”的关系。接口中的成员变量要声明为public static final，不加编译器不会报错，但是这就使得接口变得毫无意义。之所以要加static是因为接口是可以多继承的，而如果有两个接口里面都有同一个变量名，那么怎么知道这个变量名是谁的，所以要有static，而final则是因为如果谁都可以来更改接口中的变量，那么接口的至高抽象地位就丧失了（个人理解，不一定对）。当然一般接口中有成员变量的情况不是太常见。

* 强软弱虚四种引用：强引用是一般情况下的对象引用，除非置为null，不然宁可OutOfMemoryError也不会GC掉强引用。软引用是当内存不足的时候会被回收掉，因此可以用来实现内存敏感的高速缓存，可以与一个引用队列一起使用。弱引用则是每当GC的时候无论是否内存不足，都会被回收掉，可以与一个引用队列一起使用。虚引用则更像是一个空引用，仅仅给它贴了一个标签，但是什么作用都没有，必须要与一个引用队列一起使用。

* Map：map是一种特殊的set，每一个键都对应着一个或者多个值。map保证键是唯一的，这就是map最基本的定义，map翻译为映射，也十分的贴切。

  在Java中常用的map有很多，包括HashMap，Hashtable，LinkedHashMap，TreeMap，WeakHashMap，ConcurrentHashMap。

  HashMap为最常用的map类，最多只允许一条记录的键为null，允许多条记录的值为null，所有记录值为null就可以看成一个set类，其实是基于数组实现的，索引是根据键的hash值来算出来的，但是数组如果过小则非常容易产生哈希冲突，也就是键的hash值是一样的，这时候会采用链地址法将同一个键的不同的值以链表的形式连接起来，实际上数组的每一个非空元素都是Node链表的头结点。当一个键内有大于8个值且数组长度扩充到比64还大的时候将链表转成红黑树（扩充条件为实际数组内元素个数大于当前容量乘以负载因子），当键内的值的个数小于6的时候再转成链表。转成红黑树之后Node就会变为TreeNode。还有一点HashMap不是线程安全的，可以用Collections.synchronizedMap(HashMap)包装一个同步容器，此时几乎与Hashtable一样。

  Hashtable是HashMap的线程安全版，效率也有所降低。

  LinkedHashMap是保留了数据的插入顺序。

  TreeMap则可保证遍历的时候数据是有顺序的，因为内部实现是红黑树，而红黑树等二叉搜索树中序遍历都是有序的。数据比较大小的评判标准可以在初始化的时候传一个实现了Comparator接口的类来自己把握。

  WeakHashMap是用强软弱虚中的弱引用来维系引用于对象之间的关系，由于弱引用的特性导致GC的时候会将其中的对象删除掉，相应的key也会删除掉。

  ConcurrentHashMap也保证了线程安全，但是并不像Hashtable一样锁住整个表，而是根据并发的等级划分整个Map来达到线程安全，只会锁住操作的那一段数据而不是整个Map都上锁。

* List：主要是有ArrayList、Vector、LinkedList，但是LinkedList可能更多被当成队列来使用，ArrayList底层是动态数组，可扩容。Vector是线程安全的，所以一般会慢一点，LinkedList是双向链表，不涉及扩容。

* 启动线程的方式：继承Thread重写run()方法创建线程类，new一个实例调用start()方法开启新线程；实现Runnable接口，重写该类的run()方法，new一个实例并将该实例作为Thread的target创建Thread对象，调用Thread的start()方法；实现Callable接口，并实现其中的call方法，然后new一个该实现类的实例，将其用FutureTask包装起来，将包装之后的实例作为Thread的target传进去然后调用start方法开启新线程，用这种方式可以有一个返回值。

  Android中特有的AsyncTask是一个轻量级的异步类，IntentService则继承自Service可以在新开的线程中执行，此外HandlerThread创建新线程并通过Handler进行线程间通信。

* sync与Lock区别：

  | 类别     | synchronized                                                 | Lock                              |
  | -------- | ------------------------------------------------------------ | --------------------------------- |
  | 存在层次 | Java关键字，JVM层                                            | 是一个类                          |
  | 锁的释放 | 已获取锁的线程执行完同步代码，释放锁<br />线程执行发生异常，JVM会让线程释放锁 | 在finally中必须释放，不然容易死锁 |
  | 锁的获取 | 假设A线程获得锁，B线程等待，此时A阻塞，B会一直等待           | 可以尝试获得锁，线程不用一直等待  |
  | 锁状态   | 无法判断                                                     | 可以判断                          |
  | 锁类型   | 可重入 不可中断 非公平                                       | 可重入 可中断 公平/非公平皆可     |
  | 性能     | 少量同步，性能稍高                                           | 大量同步，性能稍低                |

  

* wait(),sleep(),notify()：wait是Object的方法，所有的类都继承Object，所以所有的实例对象都有这个方法，该方法只能用于synchronized修饰的方法或者是代码块中，但是此方法会连对象锁一起释放掉。sleep方法是Thread类的静态方法，可以用在任何地方，但是不会释放锁。notify以及notifyAll会使被锁对象上的一个或者是所有线程都被唤醒。

* Java锁：公平锁--按照等待时间的长短，等的时间越长，越是优先获得锁。非公平锁--不按照等待时间来算优先级，谁都可能先获得锁。

## Android框架

* OKhttp：

* Retrofit：
* Glide：

## 网络基础

* TCP：TCP是传输层协议，为了能保证数据可以送达，需要进行三次握手的过程来确定数据可以正常发送，然后通过四次挥手的过程结束传输。TCP传输数据是以一种流的形式进行的，所以没有数据边界，需要在应用端自己实现。

  首先我们来看一下TCP头部都有什么参数：

  | 0-----------------------------------------------------------15 | 16---------------------------------------------------------------31 |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 源端口（16位）                                               | 目的端口（16位）                                             |
  | 序列号（32位）                                               |                                                              |
  | 确认号（32位）                                               |                                                              |
  | 头部长度（4位）保留（4位）<br />SWR（1位）ECE（1位）<br />URG（1位）ACK（1位）<br />PSH（1位）RST（1位）<br />SYN（1位）FIN（1位） | 窗口大小（16位）                                             |
  | TCP校检和（16位）                                            | 紧急指针（16位）                                             |

  其中端口这个参数与排在TCP头部之前的IP头部中的IP地址组成了大家熟知的套接字（socket），唯一地标识了每个连接。

  序列号则代表了而每个连接中报文段的第一个字节，是一个32位无符号整型，到达2^32-1之后再循环到0。

  确认号+ACK位+窗口大小+ECE是接收端用来返回一些数值来确认是否收到信息或者是来调整窗口大小以达到流量控制的作用。确认号（ACK号或ACK字段）只有在ACK位置位的时候才有效。

  三次握手：客户端向服务端发送的第一个报文段syn位字段被启用也就是置为1，并且指明想要连接的端口号以及它的客户端初始序列号（ISN_c）。服务器收到后响应一个syn、一个ack数值以及他的初始序列号（ISN_s），为了确认客户端的syn，服务端将客户端传来的ISN_c + 1作为ack数值返回，如果客户端的syn丢失，则会重传。为了确认服务器的syn，客户端将传来的ISN_s + 1作为返回的ack数值。

  四次挥手：与三次握手类似，只不过现在的序列号已经经过多次传输发生了更改，实际流程是很类似的。通常是客户端发起结束连接的请求，向服务端发送一个fin段来表达自己想要停止发送数据，此fin段中包括一个ack值（就是对方的序列号）用来确认对方最近一次发送过来的数据，还包括一个自己的序列号。服务端收到之后为了确认自己已经收到了会将客户端传来的序列号+1作为ack值返回给客户，也携带有自己的序列号。当服务端也想关闭连接结束传输数据的时候也是同样的做法，发送一个fin段，携带有自己的序列号，ack值为客户端序列号+1，然后客户端收到之后返回一个ack值（服务端序列号+1）作为回应，进入time_wait状态，如果在2MSL（maximum segment lifetime表示数据包在网络中的最大生存时间）内无其他事情发生则表示服务端接收到了我们返回的ack值，至此连接关闭，如果因为网络原因服务端没有接收到我们的返回值服务端就会重发一个fin端，这个时候如果我们的客户端没有2MSL的时间来作缓冲而是已经关闭了就会返回一个RST端，表示连接取消，那么服务端就会认为发生了错误。

  流量控制和拥塞控制：TCP中由于接收端处理速度以及中间网络情况会要求传输速率可以动态修改，这个修改的字段就是在头部中窗口大小字段。发送端中在窗口的左边都是已经发送并确认的数据，在窗口的右边是暂时不能发送的数据，在窗口内左边是已经发送但是没有确认的数据，窗口内部的右边是即将发送的数据。接收端中在窗口的左边是已经接收并确认的数据，在窗口中的是接收后将会保存的数据，窗口右边是不能接收的数据。

* UDP：UDP也是传输层协议，但是它并不保证数据可以送达，有数据就发，其他什么都不管，也很大几率会丢失数据，但是发送速度快，通常用于对实时性很高要求但是对数据准确性要求不高的领域，比如视频直播就非常的适合。以数据包的形式来发送，故有数据边界。

* HTTPS：建立在安全套接层（SSL）之上的信息通道，一定程度上让窃取信息的成本变高，相应的也不如纯粹的HTTP那么快。但是现如今这点相比HTTP而言多出的网络资源已经微不足道，而有一类人呼吁所有网页都采用此协议以保证安全，谷歌也说采用HTTPS的网站排名相对会更高，但实际上这对于很多小型网站而言是不可能的，因为向CA购买证书每年都需要花钱，当然也可以试试一些免费的证书。除了安全性有了很大提高之外其它几乎都是负面影响：客户端网页加载变慢，服务端资源占用高很多，连接缓存不如HTTP高效，流量成本太高。而有关SSL则涉及到一些数学方面的内容，

* HTTP：超文本传输协议，互联网基石之一，在浏览器的地址栏填写地址的时候，默认就是这个协议。此协议占用80端口，以明文的形式发送内容，没有数据加密，只要第三方截取了Web浏览器和对应网页的服务器之间的传输内容，就可以直接读懂内容。好处是高效，流量少。

  HTTP请求头主要包括：请求行--方法+url+HTTP版本、HTTP首部字段--请求首部字段+通用....+实体....

  HTTP响应头主要包括：状态行--HTTP版本+状态码、HTTP首部字段--响应首部字段+通用....+实体....

  HTTP状态码主要类别：2xx--成功、3xx--重定向、4xx--客户端错误、5xx服务器错误。

* 负载均衡：使用这种技术的原因是如果只有一个服务器则web请求是这样的：User=>Internet=>Web Server=>Database Server，把鸡蛋放在一个篮子里是非常危险的，如果这个服务器发生了意外宕机则此网络资源无法访问。另外如果这个网站很受欢迎，有很多用户发起请求，在这种情况下单个服务器即使配置很高也很难处理如此多的请求，而且从经济的角度考虑，追求数量比追求配置更划算，又可以提高性能与可用性，实在没有理由不用。当然负载均衡需要额外的机器来实现，将其称为负载均衡器，一般会有几台负载均衡器来做转发，来保证不会出现因为负载均衡器挂掉使应用无法响应的情况。将请求转到另外一个负载均衡器可以使用浮动IP。

  负载均衡器主要可以为四种类型的请求设置转发规则：TCP,UDP,HTTP,HTTPS。负载均衡器会选择能对请求做出正常应答的服务器进行转发，为了监视后台服务器的状态，检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器，如果后端服务器无法通过检查则会被从healthy pool中移除，直到它通过检查为止。

  负载均衡有几个常用算法：轮询--第一个请求发到列表中的第一个服务器，第二个请求发到第二个服务器，以此类推，然后循环。最小连接--优先选择连接数最小的服务器，在普通会话较长的情况下推荐使用。Source--根据请求IP的hash值来选择要转发的服务器，可以一定程度上保证特定用户能连接到相同的服务器。

## JVM

* 新生代、老生代：（本条目下的内存特指Java堆与方法区）在多次GC之后仍然存在于内存中的对象会被移入老生代，新生代与老生代的回收算法大致如下：

  标记-清除：在堆中有效内存将要耗尽时，停下整个程序（stop-the-world），然后进行标记和清除工作，遍历所有GC Roots，然后根据根搜索算法的结果将所有可达对象标记为存活对象（标记位置为1），然后再遍历一遍堆中所有对象，将没有标记的对象（标记位为0）全部清除掉。之后将存活的对象标记位重新置为0。此种方法的缺点是多次遍历堆中对象以及要维护一个空闲列表导致的效率低下以及清理出的内存空间不连续。

  复制-清除：将原有内存空间分为两块，每次只使用其中一块，在GC的时候将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中所有的对象，将两个内存块的角色互换。因为效率比较高但是不适合有大量对象存活的情况，所以用在新生代比较合适。此方法牺牲空间换时间，实际使用的时候会将新生代内存分为一块比较大的Eden空间和两块比较小的survivor空间（Eden：survivor = 8：1），每次使用一块survivor空间和Eden空间，GC时将两块空间内存活的对象复制进入另外一块survivor空间内，然后将两块survivor空间互换角色，这样就可以很大程度上的避免了空间的浪费，仅浪费了10%却又保证了算法的效果。当有些对象比较大不能放进survivor空间的时候则会将**大对象直接放进老生代**，判断大对象的阙值可以自己指定也可使用默认值。

  标记-整理：在标记清除的基础上做了一些改动，将存活的对象堆到内存的一侧，而将另一侧全部清除掉，如此不必维护一个空闲列表只需要知道可用内存的起始地址即可。可用于老生代GC。

  ps：**stop-the-world**是java中一种全局暂停现象，native代码可以运行但是不能与JVM交互，通常由GC引起，少数情况下可能由死锁检查、dump线程、堆dump导致。至于为什么要全局暂停可以形象的理解为我们在一边嗑瓜子一边吐瓜子皮，保洁阿姨进来打扫卫生，而我们这个时候不是让到一边让保洁阿姨打扫干净，而是继续往地上吐瓜子皮...频繁GC的危害就显而易见了，轻则卡顿，重则无响应，一些高可用性集群（HA）长时间无响应引起主备机切换可能会导致灾难性后果。

  

## 计算机基础概念

* 动态链接与静态链接与PIC：静态链接会将目标程序（也就是你正在写的程序）所需要的库都复制一个副本一起编译，由于每个可执行文件都保留一个副本从而导致了空间的浪费以及单个文件过大，不同的程序有很多公用的代码造成冗余。且由于静态链接所有文件都必须共同链接以确定某个符号或者是代码的位置，导致了单个文件有一点点改动则需要重新编译整个程序。静态编译的好处就是程序执行速度快且可以自己在程序内修改副本而不用担心对其他程序产生影响。

  动态链接则可以在编译时用到哪个再去加载某个库而不用将需要的库都复制进程序里面（不同进程间共享内存通过地址映射解决），这就要求每个程序对动态链接库的同一个符号的引用是不同的。在**Linux进程的五个段中**（bbs段：存放未初始化的全局变量，数据段：存放初始化全局变量，代码段：存放程序执行代码，堆：执行时动态分配，栈：存放局部变量以及函数的参数）代码段由于是共享所以是相同的，从动态链接功能上可以看出应该放在全局变量对应的段，所以我们只能在数据段做文章。每个应用程序的数据段开头位每一个全局符号保留了一个GOT（global offset table），其中每个条目都保存了全局符号的绝对位置（在动态链接库装载的时候被填写）。使用全局符号时去GOF中遍历即可。

* 进程与线程：一个程序至少有一个进程，一个进程至少有一个线程，进程使得操作系统并发成为可能，线程使得进程内部并发成为可能，进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位，进程切换上下文耗时长，线程切换上下文耗时短。从CPU的角度来看，线程与进程其实可以理解为CPU工作时间段的描述。CPU是很快的，在CPU的角度上所有的任务都是轮流进行的：先加载程序A的上下文，然后执行A，然后保存A的上下文，然后加载B程序的上下文，然后执行B，然后保存B的上下文...

  进程就是包含上下文切换的程序执行时间总和，而线程是在这其中运行的更细小的时间段，因为不需要去保存整个程序的上下文，所以切换的时候保存的上下文信息比较少，切换速度快。

* 死锁：死锁发生的情况就是A进程占用着a资源，B进程占用着b资源，但是A和B都需要对方所占用的资源才继续运行下去，于是发生死锁。拆分总结一下死锁的四个条件是：禁止抢占--系统资源不能被强制从一个进程退出；持有和等待--一个进程可以在等待时持有系统资源；互斥--一个资源只能被一个进程持有；循环等待--一系列进程互相持有其他进程所需要的资源。只有当以上四个条件同时满足的时候死锁才会发生，预防死锁就是至少破坏其中一项。如果已经发生死锁，则终止一个进程的运行即可，或是回滚...当然也可以关机重启（0__0）

## 数据库

事务的四个性质：原子性，一致性，隔离性，持久性。